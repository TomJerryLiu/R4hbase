/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hbase_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

int _kTDeleteTypeValues[] = {
  TDeleteType::DELETE_COLUMN,
  TDeleteType::DELETE_COLUMNS
};
const char* _kTDeleteTypeNames[] = {
  "DELETE_COLUMN",
  "DELETE_COLUMNS"
};
const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDeleteTypeValues, _kTDeleteTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDurabilityValues[] = {
  TDurability::SKIP_WAL,
  TDurability::ASYNC_WAL,
  TDurability::SYNC_WAL,
  TDurability::FSYNC_WAL
};
const char* _kTDurabilityNames[] = {
  "SKIP_WAL",
  "ASYNC_WAL",
  "SYNC_WAL",
  "FSYNC_WAL"
};
const std::map<int, const char*> _TDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTDurabilityValues, _kTDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TTimeRange::~TTimeRange() throw() {
}


void TTimeRange::__set_minStamp(const int64_t val) {
  this->minStamp = val;
}

void TTimeRange::__set_maxStamp(const int64_t val) {
  this->maxStamp = val;
}

const char* TTimeRange::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TTimeRange::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minStamp = false;
  bool isset_maxStamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minStamp);
          isset_minStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxStamp);
          isset_maxStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTimeRange");

  xfer += oprot->writeFieldBegin("minStamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTimeRange &a, TTimeRange &b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

TTimeRange::TTimeRange(const TTimeRange& other0) {
  minStamp = other0.minStamp;
  maxStamp = other0.maxStamp;
}
TTimeRange& TTimeRange::operator=(const TTimeRange& other1) {
  minStamp = other1.minStamp;
  maxStamp = other1.maxStamp;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TTimeRange& obj) {
  using apache::thrift::to_string;
  out << "TTimeRange(";
  out << "minStamp=" << to_string(obj.minStamp);
  out << ", " << "maxStamp=" << to_string(obj.maxStamp);
  out << ")";
  return out;
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_family(const std::string& val) {
  this->family = val;
}

void TColumn::__set_qualifier(const std::string& val) {
  this->qualifier = val;
__isset.qualifier = true;
}

void TColumn::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

const char* TColumn::ascii_fingerprint = "354B89A42CE318BBBCE588A386D5D6CD";
const uint8_t TColumn::binary_fingerprint[16] = {0x35,0x4B,0x89,0xA4,0x2C,0xE3,0x18,0xBB,0xBC,0xE5,0x88,0xA3,0x86,0xD5,0xD6,0xCD};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other2) {
  family = other2.family;
  qualifier = other2.qualifier;
  timestamp = other2.timestamp;
  __isset = other2.__isset;
}
TColumn& TColumn::operator=(const TColumn& other3) {
  family = other3.family;
  qualifier = other3.qualifier;
  timestamp = other3.timestamp;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj) {
  using apache::thrift::to_string;
  out << "TColumn(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier="; (obj.__isset.qualifier ? (out << to_string(obj.qualifier)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ")";
  return out;
}


TColumnValue::~TColumnValue() throw() {
}


void TColumnValue::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnValue::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnValue::__set_value(const std::string& val) {
  this->value = val;
}

void TColumnValue::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TColumnValue::__set_tags(const std::string& val) {
  this->tags = val;
__isset.tags = true;
}

const char* TColumnValue::ascii_fingerprint = "276F69807920CD467661BFC2310DBC75";
const uint8_t TColumnValue::binary_fingerprint[16] = {0x27,0x6F,0x69,0x80,0x79,0x20,0xCD,0x46,0x76,0x61,0xBF,0xC2,0x31,0x0D,0xBC,0x75};

uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->tags);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other4) {
  family = other4.family;
  qualifier = other4.qualifier;
  value = other4.value;
  timestamp = other4.timestamp;
  tags = other4.tags;
  __isset = other4.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other5) {
  family = other5.family;
  qualifier = other5.qualifier;
  value = other5.value;
  timestamp = other5.timestamp;
  tags = other5.tags;
  __isset = other5.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumnValue& obj) {
  using apache::thrift::to_string;
  out << "TColumnValue(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier=" << to_string(obj.qualifier);
  out << ", " << "value=" << to_string(obj.value);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "tags="; (obj.__isset.tags ? (out << to_string(obj.tags)) : (out << "<null>"));
  out << ")";
  return out;
}


TColumnIncrement::~TColumnIncrement() throw() {
}


void TColumnIncrement::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnIncrement::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnIncrement::__set_amount(const int64_t val) {
  this->amount = val;
__isset.amount = true;
}

const char* TColumnIncrement::ascii_fingerprint = "C55F1CDA80E5E1836AFA7E590331D0A5";
const uint8_t TColumnIncrement::binary_fingerprint[16] = {0xC5,0x5F,0x1C,0xDA,0x80,0xE5,0xE1,0x83,0x6A,0xFA,0x7E,0x59,0x03,0x31,0xD0,0xA5};

uint32_t TColumnIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnIncrement");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnIncrement &a, TColumnIncrement &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

TColumnIncrement::TColumnIncrement(const TColumnIncrement& other6) {
  family = other6.family;
  qualifier = other6.qualifier;
  amount = other6.amount;
  __isset = other6.__isset;
}
TColumnIncrement& TColumnIncrement::operator=(const TColumnIncrement& other7) {
  family = other7.family;
  qualifier = other7.qualifier;
  amount = other7.amount;
  __isset = other7.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumnIncrement& obj) {
  using apache::thrift::to_string;
  out << "TColumnIncrement(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier=" << to_string(obj.qualifier);
  out << ", " << "amount="; (obj.__isset.amount ? (out << to_string(obj.amount)) : (out << "<null>"));
  out << ")";
  return out;
}


TResult::~TResult() throw() {
}


void TResult::__set_row(const std::string& val) {
  this->row = val;
__isset.row = true;
}

void TResult::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

const char* TResult::ascii_fingerprint = "B5C71AF24E317136FA61FAADC84E6F7E";
const uint8_t TResult::binary_fingerprint[16] = {0xB5,0xC7,0x1A,0xF2,0x4E,0x31,0x71,0x36,0xFA,0x61,0xFA,0xAD,0xC8,0x4E,0x6F,0x7E};

uint32_t TResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->columnValues.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->columnValues[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TResult");

  if (this->__isset.row) {
    xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->row);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter13;
    for (_iter13 = this->columnValues.begin(); _iter13 != this->columnValues.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TResult &a, TResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.__isset, b.__isset);
}

TResult::TResult(const TResult& other14) {
  row = other14.row;
  columnValues = other14.columnValues;
  __isset = other14.__isset;
}
TResult& TResult::operator=(const TResult& other15) {
  row = other15.row;
  columnValues = other15.columnValues;
  __isset = other15.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TResult& obj) {
  using apache::thrift::to_string;
  out << "TResult(";
  out << "row="; (obj.__isset.row ? (out << to_string(obj.row)) : (out << "<null>"));
  out << ", " << "columnValues=" << to_string(obj.columnValues);
  out << ")";
  return out;
}


TAuthorization::~TAuthorization() throw() {
}


void TAuthorization::__set_labels(const std::vector<std::string> & val) {
  this->labels = val;
__isset.labels = true;
}

const char* TAuthorization::ascii_fingerprint = "6A3474ADDA840BE2091105F0DFB630C7";
const uint8_t TAuthorization::binary_fingerprint[16] = {0x6A,0x34,0x74,0xAD,0xDA,0x84,0x0B,0xE2,0x09,0x11,0x05,0xF0,0xDF,0xB6,0x30,0xC7};

uint32_t TAuthorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->labels.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->labels[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAuthorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TAuthorization");

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->labels.size()));
      std::vector<std::string> ::const_iterator _iter21;
      for (_iter21 = this->labels.begin(); _iter21 != this->labels.end(); ++_iter21)
      {
        xfer += oprot->writeString((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TAuthorization &a, TAuthorization &b) {
  using ::std::swap;
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

TAuthorization::TAuthorization(const TAuthorization& other22) {
  labels = other22.labels;
  __isset = other22.__isset;
}
TAuthorization& TAuthorization::operator=(const TAuthorization& other23) {
  labels = other23.labels;
  __isset = other23.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TAuthorization& obj) {
  using apache::thrift::to_string;
  out << "TAuthorization(";
  out << "labels="; (obj.__isset.labels ? (out << to_string(obj.labels)) : (out << "<null>"));
  out << ")";
  return out;
}


TCellVisibility::~TCellVisibility() throw() {
}


void TCellVisibility::__set_expression(const std::string& val) {
  this->expression = val;
__isset.expression = true;
}

const char* TCellVisibility::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TCellVisibility::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TCellVisibility::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expression);
          this->__isset.expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCellVisibility::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCellVisibility");

  if (this->__isset.expression) {
    xfer += oprot->writeFieldBegin("expression", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->expression);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCellVisibility &a, TCellVisibility &b) {
  using ::std::swap;
  swap(a.expression, b.expression);
  swap(a.__isset, b.__isset);
}

TCellVisibility::TCellVisibility(const TCellVisibility& other24) {
  expression = other24.expression;
  __isset = other24.__isset;
}
TCellVisibility& TCellVisibility::operator=(const TCellVisibility& other25) {
  expression = other25.expression;
  __isset = other25.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TCellVisibility& obj) {
  using apache::thrift::to_string;
  out << "TCellVisibility(";
  out << "expression="; (obj.__isset.expression ? (out << to_string(obj.expression)) : (out << "<null>"));
  out << ")";
  return out;
}


TGet::~TGet() throw() {
}


void TGet::__set_row(const std::string& val) {
  this->row = val;
}

void TGet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TGet::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TGet::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TGet::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TGet::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TGet::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TGet::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

const char* TGet::ascii_fingerprint = "87176421221CD05693587C291DFAF703";
const uint8_t TGet::binary_fingerprint[16] = {0x87,0x17,0x64,0x21,0x22,0x1C,0xD0,0x56,0x93,0x58,0x7C,0x29,0x1D,0xFA,0xF7,0x03};

uint32_t TGet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->columns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->columns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readBinary(_key36);
              std::string& _val37 = this->attributes[_key36];
              xfer += iprot->readBinary(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGet");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter38;
      for (_iter38 = this->columns.begin(); _iter38 != this->columns.end(); ++_iter38)
      {
        xfer += (*_iter38).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter39;
      for (_iter39 = this->attributes.begin(); _iter39 != this->attributes.end(); ++_iter39)
      {
        xfer += oprot->writeBinary(_iter39->first);
        xfer += oprot->writeBinary(_iter39->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGet &a, TGet &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.__isset, b.__isset);
}

TGet::TGet(const TGet& other40) {
  row = other40.row;
  columns = other40.columns;
  timestamp = other40.timestamp;
  timeRange = other40.timeRange;
  maxVersions = other40.maxVersions;
  filterString = other40.filterString;
  attributes = other40.attributes;
  authorizations = other40.authorizations;
  __isset = other40.__isset;
}
TGet& TGet::operator=(const TGet& other41) {
  row = other41.row;
  columns = other41.columns;
  timestamp = other41.timestamp;
  timeRange = other41.timeRange;
  maxVersions = other41.maxVersions;
  filterString = other41.filterString;
  attributes = other41.attributes;
  authorizations = other41.authorizations;
  __isset = other41.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TGet& obj) {
  using apache::thrift::to_string;
  out << "TGet(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "timeRange="; (obj.__isset.timeRange ? (out << to_string(obj.timeRange)) : (out << "<null>"));
  out << ", " << "maxVersions="; (obj.__isset.maxVersions ? (out << to_string(obj.maxVersions)) : (out << "<null>"));
  out << ", " << "filterString="; (obj.__isset.filterString ? (out << to_string(obj.filterString)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (obj.__isset.authorizations ? (out << to_string(obj.authorizations)) : (out << "<null>"));
  out << ")";
  return out;
}


TPut::~TPut() throw() {
}


void TPut::__set_row(const std::string& val) {
  this->row = val;
}

void TPut::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TPut::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TPut::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TPut::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TPut::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

const char* TPut::ascii_fingerprint = "36CAB67E0B058E6936AEB9943AA4EFEF";
const uint8_t TPut::binary_fingerprint[16] = {0x36,0xCA,0xB6,0x7E,0x0B,0x05,0x8E,0x69,0x36,0xAE,0xB9,0x94,0x3A,0xA4,0xEF,0xEF};

uint32_t TPut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->columnValues.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->columnValues[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readBinary(_key52);
              std::string& _val53 = this->attributes[_key52];
              xfer += iprot->readBinary(_val53);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->durability = (TDurability::type)ecast54;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TPut");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter55;
    for (_iter55 = this->columnValues.begin(); _iter55 != this->columnValues.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter56;
      for (_iter56 = this->attributes.begin(); _iter56 != this->attributes.end(); ++_iter56)
      {
        xfer += oprot->writeBinary(_iter56->first);
        xfer += oprot->writeBinary(_iter56->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TPut &a, TPut &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TPut::TPut(const TPut& other57) {
  row = other57.row;
  columnValues = other57.columnValues;
  timestamp = other57.timestamp;
  attributes = other57.attributes;
  durability = other57.durability;
  cellVisibility = other57.cellVisibility;
  __isset = other57.__isset;
}
TPut& TPut::operator=(const TPut& other58) {
  row = other58.row;
  columnValues = other58.columnValues;
  timestamp = other58.timestamp;
  attributes = other58.attributes;
  durability = other58.durability;
  cellVisibility = other58.cellVisibility;
  __isset = other58.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TPut& obj) {
  using apache::thrift::to_string;
  out << "TPut(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columnValues=" << to_string(obj.columnValues);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ")";
  return out;
}


TDelete::~TDelete() throw() {
}


void TDelete::__set_row(const std::string& val) {
  this->row = val;
}

void TDelete::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TDelete::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TDelete::__set_deleteType(const TDeleteType::type val) {
  this->deleteType = val;
__isset.deleteType = true;
}

void TDelete::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TDelete::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

const char* TDelete::ascii_fingerprint = "84640DFE212CEB30848C27DC77C196F0";
const uint8_t TDelete::binary_fingerprint[16] = {0x84,0x64,0x0D,0xFE,0x21,0x2C,0xEB,0x30,0x84,0x8C,0x27,0xDC,0x77,0xC1,0x96,0xF0};

uint32_t TDelete::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->columns.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->columns[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->deleteType = (TDeleteType::type)ecast64;
          this->__isset.deleteType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _ktype66;
            ::apache::thrift::protocol::TType _vtype67;
            xfer += iprot->readMapBegin(_ktype66, _vtype67, _size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              std::string _key70;
              xfer += iprot->readBinary(_key70);
              std::string& _val71 = this->attributes[_key70];
              xfer += iprot->readBinary(_val71);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->durability = (TDurability::type)ecast72;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDelete::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TDelete");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter73;
      for (_iter73 = this->columns.begin(); _iter73 != this->columns.end(); ++_iter73)
      {
        xfer += (*_iter73).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteType) {
    xfer += oprot->writeFieldBegin("deleteType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->deleteType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter74;
      for (_iter74 = this->attributes.begin(); _iter74 != this->attributes.end(); ++_iter74)
      {
        xfer += oprot->writeBinary(_iter74->first);
        xfer += oprot->writeBinary(_iter74->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TDelete &a, TDelete &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TDelete::TDelete(const TDelete& other75) {
  row = other75.row;
  columns = other75.columns;
  timestamp = other75.timestamp;
  deleteType = other75.deleteType;
  attributes = other75.attributes;
  durability = other75.durability;
  __isset = other75.__isset;
}
TDelete& TDelete::operator=(const TDelete& other76) {
  row = other76.row;
  columns = other76.columns;
  timestamp = other76.timestamp;
  deleteType = other76.deleteType;
  attributes = other76.attributes;
  durability = other76.durability;
  __isset = other76.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TDelete& obj) {
  using apache::thrift::to_string;
  out << "TDelete(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "deleteType="; (obj.__isset.deleteType ? (out << to_string(obj.deleteType)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ")";
  return out;
}


TIncrement::~TIncrement() throw() {
}


void TIncrement::__set_row(const std::string& val) {
  this->row = val;
}

void TIncrement::__set_columns(const std::vector<TColumnIncrement> & val) {
  this->columns = val;
}

void TIncrement::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TIncrement::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TIncrement::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

const char* TIncrement::ascii_fingerprint = "934009D90034B21D193901BC945D91F0";
const uint8_t TIncrement::binary_fingerprint[16] = {0x93,0x40,0x09,0xD9,0x00,0x34,0xB2,0x1D,0x19,0x39,0x01,0xBC,0x94,0x5D,0x91,0xF0};

uint32_t TIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->columns.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->columns[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readBinary(_key87);
              std::string& _val88 = this->attributes[_key87];
              xfer += iprot->readBinary(_val88);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->durability = (TDurability::type)ecast89;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIncrement");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnIncrement> ::const_iterator _iter90;
    for (_iter90 = this->columns.begin(); _iter90 != this->columns.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter91;
      for (_iter91 = this->attributes.begin(); _iter91 != this->attributes.end(); ++_iter91)
      {
        xfer += oprot->writeBinary(_iter91->first);
        xfer += oprot->writeBinary(_iter91->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIncrement &a, TIncrement &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TIncrement::TIncrement(const TIncrement& other92) {
  row = other92.row;
  columns = other92.columns;
  attributes = other92.attributes;
  durability = other92.durability;
  cellVisibility = other92.cellVisibility;
  __isset = other92.__isset;
}
TIncrement& TIncrement::operator=(const TIncrement& other93) {
  row = other93.row;
  columns = other93.columns;
  attributes = other93.attributes;
  durability = other93.durability;
  cellVisibility = other93.cellVisibility;
  __isset = other93.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIncrement& obj) {
  using apache::thrift::to_string;
  out << "TIncrement(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns=" << to_string(obj.columns);
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ")";
  return out;
}


TAppend::~TAppend() throw() {
}


void TAppend::__set_row(const std::string& val) {
  this->row = val;
}

void TAppend::__set_columns(const std::vector<TColumnValue> & val) {
  this->columns = val;
}

void TAppend::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TAppend::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TAppend::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

const char* TAppend::ascii_fingerprint = "B9D1B1096052DCCFFB5AF5C6270D8D26";
const uint8_t TAppend::binary_fingerprint[16] = {0xB9,0xD1,0xB1,0x09,0x60,0x52,0xDC,0xCF,0xFB,0x5A,0xF5,0xC6,0x27,0x0D,0x8D,0x26};

uint32_t TAppend::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->columns.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->columns[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _ktype100;
            ::apache::thrift::protocol::TType _vtype101;
            xfer += iprot->readMapBegin(_ktype100, _vtype101, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              std::string _key104;
              xfer += iprot->readBinary(_key104);
              std::string& _val105 = this->attributes[_key104];
              xfer += iprot->readBinary(_val105);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->durability = (TDurability::type)ecast106;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAppend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TAppend");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnValue> ::const_iterator _iter107;
    for (_iter107 = this->columns.begin(); _iter107 != this->columns.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter108;
      for (_iter108 = this->attributes.begin(); _iter108 != this->attributes.end(); ++_iter108)
      {
        xfer += oprot->writeBinary(_iter108->first);
        xfer += oprot->writeBinary(_iter108->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TAppend &a, TAppend &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TAppend::TAppend(const TAppend& other109) {
  row = other109.row;
  columns = other109.columns;
  attributes = other109.attributes;
  durability = other109.durability;
  cellVisibility = other109.cellVisibility;
  __isset = other109.__isset;
}
TAppend& TAppend::operator=(const TAppend& other110) {
  row = other110.row;
  columns = other110.columns;
  attributes = other110.attributes;
  durability = other110.durability;
  cellVisibility = other110.cellVisibility;
  __isset = other110.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TAppend& obj) {
  using apache::thrift::to_string;
  out << "TAppend(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns=" << to_string(obj.columns);
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ")";
  return out;
}


TScan::~TScan() throw() {
}


void TScan::__set_startRow(const std::string& val) {
  this->startRow = val;
__isset.startRow = true;
}

void TScan::__set_stopRow(const std::string& val) {
  this->stopRow = val;
__isset.stopRow = true;
}

void TScan::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TScan::__set_caching(const int32_t val) {
  this->caching = val;
__isset.caching = true;
}

void TScan::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TScan::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TScan::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TScan::__set_batchSize(const int32_t val) {
  this->batchSize = val;
__isset.batchSize = true;
}

void TScan::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TScan::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TScan::__set_reversed(const bool val) {
  this->reversed = val;
__isset.reversed = true;
}

const char* TScan::ascii_fingerprint = "4B08177957744695A7ABAB13D3D2FD26";
const uint8_t TScan::binary_fingerprint[16] = {0x4B,0x08,0x17,0x79,0x57,0x74,0x46,0x95,0xA7,0xAB,0xAB,0x13,0xD3,0xD2,0xFD,0x26};

uint32_t TScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->stopRow);
          this->__isset.stopRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->columns.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->columns[_i115].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _ktype117;
            ::apache::thrift::protocol::TType _vtype118;
            xfer += iprot->readMapBegin(_ktype117, _vtype118, _size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              std::string _key121;
              xfer += iprot->readBinary(_key121);
              std::string& _val122 = this->attributes[_key121];
              xfer += iprot->readBinary(_val122);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          this->__isset.reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TScan");

  if (this->__isset.startRow) {
    xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->startRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopRow) {
    xfer += oprot->writeFieldBegin("stopRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->stopRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter123;
      for (_iter123 = this->columns.begin(); _iter123 != this->columns.end(); ++_iter123)
      {
        xfer += (*_iter123).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchSize) {
    xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->batchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter124;
      for (_iter124 = this->attributes.begin(); _iter124 != this->attributes.end(); ++_iter124)
      {
        xfer += oprot->writeBinary(_iter124->first);
        xfer += oprot->writeBinary(_iter124->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reversed) {
    xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->reversed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TScan &a, TScan &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.reversed, b.reversed);
  swap(a.__isset, b.__isset);
}

TScan::TScan(const TScan& other125) {
  startRow = other125.startRow;
  stopRow = other125.stopRow;
  columns = other125.columns;
  caching = other125.caching;
  maxVersions = other125.maxVersions;
  timeRange = other125.timeRange;
  filterString = other125.filterString;
  batchSize = other125.batchSize;
  attributes = other125.attributes;
  authorizations = other125.authorizations;
  reversed = other125.reversed;
  __isset = other125.__isset;
}
TScan& TScan::operator=(const TScan& other126) {
  startRow = other126.startRow;
  stopRow = other126.stopRow;
  columns = other126.columns;
  caching = other126.caching;
  maxVersions = other126.maxVersions;
  timeRange = other126.timeRange;
  filterString = other126.filterString;
  batchSize = other126.batchSize;
  attributes = other126.attributes;
  authorizations = other126.authorizations;
  reversed = other126.reversed;
  __isset = other126.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TScan& obj) {
  using apache::thrift::to_string;
  out << "TScan(";
  out << "startRow="; (obj.__isset.startRow ? (out << to_string(obj.startRow)) : (out << "<null>"));
  out << ", " << "stopRow="; (obj.__isset.stopRow ? (out << to_string(obj.stopRow)) : (out << "<null>"));
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "caching="; (obj.__isset.caching ? (out << to_string(obj.caching)) : (out << "<null>"));
  out << ", " << "maxVersions="; (obj.__isset.maxVersions ? (out << to_string(obj.maxVersions)) : (out << "<null>"));
  out << ", " << "timeRange="; (obj.__isset.timeRange ? (out << to_string(obj.timeRange)) : (out << "<null>"));
  out << ", " << "filterString="; (obj.__isset.filterString ? (out << to_string(obj.filterString)) : (out << "<null>"));
  out << ", " << "batchSize="; (obj.__isset.batchSize ? (out << to_string(obj.batchSize)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (obj.__isset.authorizations ? (out << to_string(obj.authorizations)) : (out << "<null>"));
  out << ", " << "reversed="; (obj.__isset.reversed ? (out << to_string(obj.reversed)) : (out << "<null>"));
  out << ")";
  return out;
}


TMutation::~TMutation() throw() {
}


void TMutation::__set_put(const TPut& val) {
  this->put = val;
}

void TMutation::__set_deleteSingle(const TDelete& val) {
  this->deleteSingle = val;
}

const char* TMutation::ascii_fingerprint = "4F38C9BED32D7E5B2DA57B53EDD3D974";
const uint8_t TMutation::binary_fingerprint[16] = {0x4F,0x38,0xC9,0xBE,0xD3,0x2D,0x7E,0x5B,0x2D,0xA5,0x7B,0x53,0xED,0xD3,0xD9,0x74};

uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->put.read(iprot);
          this->__isset.put = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteSingle.read(iprot);
          this->__isset.deleteSingle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TMutation");

  xfer += oprot->writeFieldBegin("put", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->put.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleteSingle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->deleteSingle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.put, b.put);
  swap(a.deleteSingle, b.deleteSingle);
  swap(a.__isset, b.__isset);
}

TMutation::TMutation(const TMutation& other127) {
  put = other127.put;
  deleteSingle = other127.deleteSingle;
  __isset = other127.__isset;
}
TMutation& TMutation::operator=(const TMutation& other128) {
  put = other128.put;
  deleteSingle = other128.deleteSingle;
  __isset = other128.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TMutation& obj) {
  using apache::thrift::to_string;
  out << "TMutation(";
  out << "put=" << to_string(obj.put);
  out << ", " << "deleteSingle=" << to_string(obj.deleteSingle);
  out << ")";
  return out;
}


TRowMutations::~TRowMutations() throw() {
}


void TRowMutations::__set_row(const std::string& val) {
  this->row = val;
}

void TRowMutations::__set_mutations(const std::vector<TMutation> & val) {
  this->mutations = val;
}

const char* TRowMutations::ascii_fingerprint = "6DE68A95A997F59AEFF591261CBB8849";
const uint8_t TRowMutations::binary_fingerprint[16] = {0x6D,0xE6,0x8A,0x95,0xA9,0x97,0xF5,0x9A,0xEF,0xF5,0x91,0x26,0x1C,0xBB,0x88,0x49};

uint32_t TRowMutations::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_mutations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->mutations.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += this->mutations[_i133].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mutations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowMutations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRowMutations");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<TMutation> ::const_iterator _iter134;
    for (_iter134 = this->mutations.begin(); _iter134 != this->mutations.end(); ++_iter134)
    {
      xfer += (*_iter134).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRowMutations &a, TRowMutations &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

TRowMutations::TRowMutations(const TRowMutations& other135) {
  row = other135.row;
  mutations = other135.mutations;
}
TRowMutations& TRowMutations::operator=(const TRowMutations& other136) {
  row = other136.row;
  mutations = other136.mutations;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TRowMutations& obj) {
  using apache::thrift::to_string;
  out << "TRowMutations(";
  out << "row=" << to_string(obj.row);
  out << ", " << "mutations=" << to_string(obj.mutations);
  out << ")";
  return out;
}


THRegionInfo::~THRegionInfo() throw() {
}


void THRegionInfo::__set_regionId(const int64_t val) {
  this->regionId = val;
}

void THRegionInfo::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void THRegionInfo::__set_startKey(const std::string& val) {
  this->startKey = val;
__isset.startKey = true;
}

void THRegionInfo::__set_endKey(const std::string& val) {
  this->endKey = val;
__isset.endKey = true;
}

void THRegionInfo::__set_offline(const bool val) {
  this->offline = val;
__isset.offline = true;
}

void THRegionInfo::__set_split(const bool val) {
  this->split = val;
__isset.split = true;
}

void THRegionInfo::__set_replicaId(const int32_t val) {
  this->replicaId = val;
__isset.replicaId = true;
}

const char* THRegionInfo::ascii_fingerprint = "E29D5A124268D48991C782591956E9C4";
const uint8_t THRegionInfo::binary_fingerprint[16] = {0xE2,0x9D,0x5A,0x12,0x42,0x68,0xD4,0x89,0x91,0xC7,0x82,0x59,0x19,0x56,0xE9,0xC4};

uint32_t THRegionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_regionId = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->regionId);
          isset_regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offline);
          this->__isset.offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->split);
          this->__isset.split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replicaId);
          this->__isset.replicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_regionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("THRegionInfo");

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->regionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startKey) {
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endKey) {
    xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->endKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline) {
    xfer += oprot->writeFieldBegin("offline", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split) {
    xfer += oprot->writeFieldBegin("split", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->split);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaId) {
    xfer += oprot->writeFieldBegin("replicaId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->replicaId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(THRegionInfo &a, THRegionInfo &b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.tableName, b.tableName);
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.offline, b.offline);
  swap(a.split, b.split);
  swap(a.replicaId, b.replicaId);
  swap(a.__isset, b.__isset);
}

THRegionInfo::THRegionInfo(const THRegionInfo& other137) {
  regionId = other137.regionId;
  tableName = other137.tableName;
  startKey = other137.startKey;
  endKey = other137.endKey;
  offline = other137.offline;
  split = other137.split;
  replicaId = other137.replicaId;
  __isset = other137.__isset;
}
THRegionInfo& THRegionInfo::operator=(const THRegionInfo& other138) {
  regionId = other138.regionId;
  tableName = other138.tableName;
  startKey = other138.startKey;
  endKey = other138.endKey;
  offline = other138.offline;
  split = other138.split;
  replicaId = other138.replicaId;
  __isset = other138.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const THRegionInfo& obj) {
  using apache::thrift::to_string;
  out << "THRegionInfo(";
  out << "regionId=" << to_string(obj.regionId);
  out << ", " << "tableName=" << to_string(obj.tableName);
  out << ", " << "startKey="; (obj.__isset.startKey ? (out << to_string(obj.startKey)) : (out << "<null>"));
  out << ", " << "endKey="; (obj.__isset.endKey ? (out << to_string(obj.endKey)) : (out << "<null>"));
  out << ", " << "offline="; (obj.__isset.offline ? (out << to_string(obj.offline)) : (out << "<null>"));
  out << ", " << "split="; (obj.__isset.split ? (out << to_string(obj.split)) : (out << "<null>"));
  out << ", " << "replicaId="; (obj.__isset.replicaId ? (out << to_string(obj.replicaId)) : (out << "<null>"));
  out << ")";
  return out;
}


TServerName::~TServerName() throw() {
}


void TServerName::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void TServerName::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void TServerName::__set_startCode(const int64_t val) {
  this->startCode = val;
__isset.startCode = true;
}

const char* TServerName::ascii_fingerprint = "382A5014141BA5C913BB4175A5B43756";
const uint8_t TServerName::binary_fingerprint[16] = {0x38,0x2A,0x50,0x14,0x14,0x1B,0xA5,0xC9,0x13,0xBB,0x41,0x75,0xA5,0xB4,0x37,0x56};

uint32_t TServerName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startCode);
          this->__isset.startCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TServerName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TServerName");

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startCode) {
    xfer += oprot->writeFieldBegin("startCode", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TServerName &a, TServerName &b) {
  using ::std::swap;
  swap(a.hostName, b.hostName);
  swap(a.port, b.port);
  swap(a.startCode, b.startCode);
  swap(a.__isset, b.__isset);
}

TServerName::TServerName(const TServerName& other139) {
  hostName = other139.hostName;
  port = other139.port;
  startCode = other139.startCode;
  __isset = other139.__isset;
}
TServerName& TServerName::operator=(const TServerName& other140) {
  hostName = other140.hostName;
  port = other140.port;
  startCode = other140.startCode;
  __isset = other140.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TServerName& obj) {
  using apache::thrift::to_string;
  out << "TServerName(";
  out << "hostName=" << to_string(obj.hostName);
  out << ", " << "port="; (obj.__isset.port ? (out << to_string(obj.port)) : (out << "<null>"));
  out << ", " << "startCode="; (obj.__isset.startCode ? (out << to_string(obj.startCode)) : (out << "<null>"));
  out << ")";
  return out;
}


THRegionLocation::~THRegionLocation() throw() {
}


void THRegionLocation::__set_serverName(const TServerName& val) {
  this->serverName = val;
}

void THRegionLocation::__set_regionInfo(const THRegionInfo& val) {
  this->regionInfo = val;
}

const char* THRegionLocation::ascii_fingerprint = "95ADA83616D80A12727CC523B6EFC295";
const uint8_t THRegionLocation::binary_fingerprint[16] = {0x95,0xAD,0xA8,0x36,0x16,0xD8,0x0A,0x12,0x72,0x7C,0xC5,0x23,0xB6,0xEF,0xC2,0x95};

uint32_t THRegionLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverName = false;
  bool isset_regionInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverName.read(iprot);
          isset_serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->regionInfo.read(iprot);
          isset_regionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_regionInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("THRegionLocation");

  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serverName.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->regionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(THRegionLocation &a, THRegionLocation &b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.regionInfo, b.regionInfo);
}

THRegionLocation::THRegionLocation(const THRegionLocation& other141) {
  serverName = other141.serverName;
  regionInfo = other141.regionInfo;
}
THRegionLocation& THRegionLocation::operator=(const THRegionLocation& other142) {
  serverName = other142.serverName;
  regionInfo = other142.regionInfo;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const THRegionLocation& obj) {
  using apache::thrift::to_string;
  out << "THRegionLocation(";
  out << "serverName=" << to_string(obj.serverName);
  out << ", " << "regionInfo=" << to_string(obj.regionInfo);
  out << ")";
  return out;
}


TIOError::~TIOError() throw() {
}


void TIOError::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

const char* TIOError::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TIOError::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TIOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIOError");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIOError &a, TIOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIOError::TIOError(const TIOError& other143) : TException() {
  message = other143.message;
  __isset = other143.__isset;
}
TIOError& TIOError::operator=(const TIOError& other144) {
  message = other144.message;
  __isset = other144.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIOError& obj) {
  using apache::thrift::to_string;
  out << "TIOError(";
  out << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ")";
  return out;
}


TIllegalArgument::~TIllegalArgument() throw() {
}


void TIllegalArgument::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

const char* TIllegalArgument::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TIllegalArgument::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TIllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIllegalArgument");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIllegalArgument &a, TIllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIllegalArgument::TIllegalArgument(const TIllegalArgument& other145) : TException() {
  message = other145.message;
  __isset = other145.__isset;
}
TIllegalArgument& TIllegalArgument::operator=(const TIllegalArgument& other146) {
  message = other146.message;
  __isset = other146.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIllegalArgument& obj) {
  using apache::thrift::to_string;
  out << "TIllegalArgument(";
  out << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ")";
  return out;
}

}}}} // namespace
